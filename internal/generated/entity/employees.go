// Code generated by `tools/entity-gen`. DO NOT EDIT.
package entity

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"time"

	"github.com/imantung/boilerplate-go-backend/internal/app/infra/di"
	"github.com/imantung/boilerplate-go-backend/pkg/sqkit"
	"github.com/imantung/dbtxn"

	sq "github.com/Masterminds/squirrel"
)

var (
	EmployeeTableName = "employees"
	EmployeeColumns   = struct {
		ID             string
		EmployeeName   string
		JobTitle       string
		LastCheckInAt  string
		LastCheckOutAt string
		DeletedAt      string
		UpdatedAt      string
		CreatedAt      string
	}{
		ID:             "id",
		EmployeeName:   "employee_name",
		JobTitle:       "job_title",
		LastCheckInAt:  "last_check_in_at",
		LastCheckOutAt: "last_check_out_at",
		DeletedAt:      "deleted_at",
		UpdatedAt:      "updated_at",
		CreatedAt:      "created_at",
	}
)

type (
	Employee struct {
		ID             int        `column:"id"`
		EmployeeName   string     `column:"employee_name"`
		JobTitle       string     `column:"job_title"`
		LastCheckInAt  *time.Time `column:"last_check_in_at"`
		LastCheckOutAt *time.Time `column:"last_check_out_at"`
		DeletedAt      *time.Time `column:"deleted_at"`
		UpdatedAt      time.Time  `column:"updated_at"`
		CreatedAt      time.Time  `column:"created_at"`
	}
	EmployeeRepo interface {
		Count(context.Context, ...sqkit.SelectOption) (int64, error)
		Find(context.Context, ...sqkit.SelectOption) ([]*Employee, error)
		Insert(context.Context, *Employee) (int, error)
		SoftDelete(context.Context, int) error
		Update(context.Context, *Employee, ...sqkit.UpdateOption) (int64, error)
		Patch(context.Context, *Employee, ...sqkit.UpdateOption) (int64, error)
	}
	EmployeeRepoImpl struct {
		*sql.DB
	}
)

var _ = di.Provide(NewEmployeeRepo)

func NewEmployeeRepo(db *sql.DB) EmployeeRepo {
	return &EmployeeRepoImpl{
		DB: db,
	}
}

func (r *EmployeeRepoImpl) Count(ctx context.Context, opts ...sqkit.SelectOption) (int64, error) {
	txn, err := dbtxn.Use(ctx, r.DB)
	if err != nil {
		return -1, err
	}
	builder := sq.
		Select("count(1)").
		From("employees").
		Where(sq.NotEq{"is_deleted": nil}).
		RunWith(txn)

	for _, opt := range opts {
		builder = opt.CompileSelect(builder)
	}

	row := builder.QueryRowContext(ctx)

	var cnt int64
	if err := row.Scan(&cnt); err != nil {
		return -1, err
	}
	return cnt, nil
}

func (r *EmployeeRepoImpl) Find(ctx context.Context, opts ...sqkit.SelectOption) ([]*Employee, error) {
	txn, err := dbtxn.Use(ctx, r.DB)
	if err != nil {
		return nil, err
	}
	builder := sq.
		Select(
			"id",
			"employee_name",
			"job_title",
			"last_check_in_at",
			"last_check_out_at",
			"deleted_at",
			"updated_at",
			"created_at",
		).
		From("employees").
		Where(sq.NotEq{"is_deleted": nil}).
		PlaceholderFormat(sq.Dollar).
		RunWith(txn)

	for _, opt := range opts {
		builder = opt.CompileSelect(builder)
	}

	rows, err := builder.QueryContext(ctx)
	if err != nil {
		return nil, err
	}

	list := make([]*Employee, 0)
	for rows.Next() {
		ent := new(Employee)
		err := rows.Scan(
			&ent.ID,
			&ent.EmployeeName,
			&ent.JobTitle,
			&ent.LastCheckInAt,
			&ent.LastCheckOutAt,
			&ent.DeletedAt,
			&ent.UpdatedAt,
			&ent.CreatedAt,
		)
		if err != nil {
			return nil, err
		}
		list = append(list, ent)
	}
	return list, nil
}

func (r *EmployeeRepoImpl) Insert(ctx context.Context, ent *Employee) (int, error) {
	txn, err := dbtxn.Use(ctx, r.DB)
	if err != nil {
		return -1, err
	}

	builder := sq.
		Insert("employees").
		Columns(
			"employee_name",
			"job_title",
			"last_check_in_at",
			"last_check_out_at",
		).
		Suffix(
			fmt.Sprintf("RETURNING \"%s\"", "id"),
		).
		PlaceholderFormat(sq.Dollar).
		Values(
			ent.EmployeeName,
			ent.JobTitle,
			ent.LastCheckInAt,
			ent.LastCheckOutAt,
		)

	scanner := builder.RunWith(txn).QueryRowContext(ctx)

	var id int
	if err := scanner.Scan(&id); err != nil {
		txn.AppendError(err)
		return -1, err
	}
	return id, nil
}

func (r *EmployeeRepoImpl) Update(ctx context.Context, ent *Employee, opts ...sqkit.UpdateOption) (int64, error) {
	txn, err := dbtxn.Use(ctx, r.DB)
	if err != nil {
		return -1, err
	}

	builder := sq.
		Update("employees").
		Set("employee_name", ent.EmployeeName).
		Set("job_title", ent.JobTitle).
		Set("last_check_in_at", ent.LastCheckInAt).
		Set("last_check_out_at", ent.LastCheckOutAt).
		Set("updated_at", "default").
		PlaceholderFormat(sq.Dollar).
		RunWith(txn)

	for _, opt := range opts {
		builder = opt.CompileUpdate(builder)
	}

	res, err := builder.ExecContext(ctx)
	if err != nil {
		txn.AppendError(err)
		return -1, err
	}
	affectedRow, err := res.RowsAffected()
	txn.AppendError(err)
	return affectedRow, err
}

func (r *EmployeeRepoImpl) Patch(ctx context.Context, ent *Employee, opts ...sqkit.UpdateOption) (int64, error) {
	txn, err := dbtxn.Use(ctx, r.DB)
	if err != nil {
		return -1, err
	}

	builder := sq.
		Update("employees").
		PlaceholderFormat(sq.Dollar).
		RunWith(txn)

	if !reflect.ValueOf(ent.EmployeeName).IsZero() {
		builder = builder.Set("employee_name", ent.EmployeeName)
	}
	if !reflect.ValueOf(ent.JobTitle).IsZero() {
		builder = builder.Set("job_title", ent.JobTitle)
	}
	if !reflect.ValueOf(ent.LastCheckInAt).IsZero() {
		builder = builder.Set("last_check_in_at", ent.LastCheckInAt)
	}
	if !reflect.ValueOf(ent.LastCheckOutAt).IsZero() {
		builder = builder.Set("last_check_out_at", ent.LastCheckOutAt)
	}

	builder = builder.Set("updated_at", "default")

	for _, opt := range opts {
		builder = opt.CompileUpdate(builder)
	}

	res, err := builder.ExecContext(ctx)
	if err != nil {
		txn.AppendError(err)
		return -1, err
	}

	affectedRow, err := res.RowsAffected()
	txn.AppendError(err)
	return affectedRow, err
}

func (r *EmployeeRepoImpl) SoftDelete(ctx context.Context, id int) error {
	txn, err := dbtxn.Use(ctx, r.DB)
	if err != nil {
		return err
	}

	builder := sq.
		Update("employees").
		Set("updated_at", "now()").
		PlaceholderFormat(sq.Dollar).
		RunWith(txn)

	res, err := builder.ExecContext(ctx)
	if err != nil {
		txn.AppendError(err)
		return err
	}
	affectedRow, err := res.RowsAffected()
	txn.AppendError(err)

	if affectedRow < 1 {
		return sql.ErrNoRows
	}

	return nil
}
