// Code generated by `tools/entity-gen`. DO NOT EDIT.
package entity

import (
	"context"
	"database/sql"
	"fmt"
	"time"

	"github.com/imantung/boilerplate-go-backend/internal/app/infra/di"
	"github.com/imantung/boilerplate-go-backend/pkg/repokit"
	"github.com/imantung/dbtxn"

	sq "github.com/Masterminds/squirrel"
)

var (
	EmployeeTableName = "employees"
	EmployeeColumns   = struct {
		ID             string
		EmployeeName   string
		JobTitle       string
		LastClockInAt  string
		LastClockOutAt string
		DeletedAt      string
		UpdatedAt      string
		CreatedAt      string
	}{
		ID:             "id",
		EmployeeName:   "employee_name",
		JobTitle:       "job_title",
		LastClockInAt:  "last_clock_in_at",
		LastClockOutAt: "last_clock_out_at",
		DeletedAt:      "deleted_at",
		UpdatedAt:      "updated_at",
		CreatedAt:      "created_at",
	}
)

type (
	Employee struct {
		ID             int        `column:"id"`
		EmployeeName   string     `column:"employee_name"`
		JobTitle       string     `column:"job_title"`
		LastClockInAt  *time.Time `column:"last_clock_in_at"`
		LastClockOutAt *time.Time `column:"last_clock_out_at"`
		DeletedAt      *time.Time `column:"deleted_at"`
		UpdatedAt      time.Time  `column:"updated_at"`
		CreatedAt      time.Time  `column:"created_at"`
	}
	EmployeeRepo interface {
		Count(context.Context, ...repokit.SelectOption) (int64, error)
		Select(context.Context, ...repokit.SelectOption) ([]*Employee, error)
		Insert(context.Context, *Employee) (int, error)
		SoftDelete(context.Context, int) (int64, error)
		Update(context.Context, *Employee, ...repokit.UpdateOption) (int64, error)
		Patch(context.Context, *Employee, ...repokit.UpdateOption) (int64, error)
	}
	EmployeeRepoImpl struct {
		*sql.DB
	}
)

var _ = di.Provide(NewEmployeeRepo)

func NewEmployeeRepo(db *sql.DB) EmployeeRepo {
	return &EmployeeRepoImpl{
		DB: db,
	}
}

func (r *EmployeeRepoImpl) Count(ctx context.Context, opts ...repokit.SelectOption) (int64, error) {
	txn, err := dbtxn.Use(ctx, r.DB)
	if err != nil {
		return -1, err
	}
	builder := sq.
		Select("count(1)").
		From("employees").
		Where(sq.Eq{"deleted_at": nil}).
		RunWith(txn)

	for _, opt := range opts {
		builder = opt.CompileSelect(builder)
	}

	row := builder.QueryRowContext(ctx)

	var cnt int64
	if err := row.Scan(&cnt); err != nil {
		return -1, err
	}
	return cnt, nil
}

func (r *EmployeeRepoImpl) Select(ctx context.Context, opts ...repokit.SelectOption) ([]*Employee, error) {
	txn, err := dbtxn.Use(ctx, r.DB)
	if err != nil {
		return nil, err
	}
	builder := sq.
		Select(
			"id",
			"employee_name",
			"job_title",
			"last_clock_in_at",
			"last_clock_out_at",
			"deleted_at",
			"updated_at",
			"created_at",
		).
		From("employees").
		Where(sq.Eq{"deleted_at": nil}).
		PlaceholderFormat(sq.Dollar).
		RunWith(txn)

	for _, opt := range opts {
		builder = opt.CompileSelect(builder)
	}

	rows, err := builder.QueryContext(ctx)
	if err != nil {
		return nil, err
	}

	list := make([]*Employee, 0)
	for rows.Next() {
		ent := new(Employee)
		err := rows.Scan(
			&ent.ID,
			&ent.EmployeeName,
			&ent.JobTitle,
			&ent.LastClockInAt,
			&ent.LastClockOutAt,
			&ent.DeletedAt,
			&ent.UpdatedAt,
			&ent.CreatedAt,
		)
		if err != nil {
			return nil, err
		}
		list = append(list, ent)
	}
	return list, nil
}

func (r *EmployeeRepoImpl) Insert(ctx context.Context, ent *Employee) (int, error) {
	txn, err := dbtxn.Use(ctx, r.DB)
	if err != nil {
		return -1, err
	}

	builder := sq.
		Insert("employees").
		Columns(
			"employee_name",
			"job_title",
			"last_clock_in_at",
			"last_clock_out_at",
		).
		Suffix(
			fmt.Sprintf("RETURNING \"%s\"", "id"),
		).
		PlaceholderFormat(sq.Dollar).
		Values(
			ent.EmployeeName,
			ent.JobTitle,
			ent.LastClockInAt,
			ent.LastClockOutAt,
		)

	scanner := builder.RunWith(txn).QueryRowContext(ctx)

	var id int
	if err := scanner.Scan(&id); err != nil {
		txn.AppendError(err)
		return -1, err
	}
	return id, nil
}

func (r *EmployeeRepoImpl) Update(ctx context.Context, ent *Employee, opts ...repokit.UpdateOption) (int64, error) {
	txn, err := dbtxn.Use(ctx, r.DB)
	if err != nil {
		return -1, err
	}

	builder := sq.
		Update("employees").
		Set("employee_name", ent.EmployeeName).
		Set("job_title", ent.JobTitle).
		Set("last_clock_in_at", ent.LastClockInAt).
		Set("last_clock_out_at", ent.LastClockOutAt).
		Set("updated_at", "now()").
		PlaceholderFormat(sq.Dollar).
		RunWith(txn)

	for _, opt := range opts {
		builder = opt.CompileUpdate(builder)
	}

	res, err := builder.ExecContext(ctx)
	if err != nil {
		txn.AppendError(err)
		return -1, err
	}
	affectedRow, err := res.RowsAffected()
	txn.AppendError(err)
	return affectedRow, err
}

func (r *EmployeeRepoImpl) Patch(ctx context.Context, ent *Employee, opts ...repokit.UpdateOption) (int64, error) {
	txn, err := dbtxn.Use(ctx, r.DB)
	if err != nil {
		return -1, err
	}

	builder := sq.
		Update("employees").
		PlaceholderFormat(sq.Dollar).
		RunWith(txn)

	if !repokit.IsZero(ent.EmployeeName) {
		builder = builder.Set("employee_name", ent.EmployeeName)
	}
	if !repokit.IsZero(ent.JobTitle) {
		builder = builder.Set("job_title", ent.JobTitle)
	}
	if !repokit.IsZero(ent.LastClockInAt) {
		builder = builder.Set("last_clock_in_at", ent.LastClockInAt)
	}
	if !repokit.IsZero(ent.LastClockOutAt) {
		builder = builder.Set("last_clock_out_at", ent.LastClockOutAt)
	}

	builder = builder.Set("updated_at", "now()")

	for _, opt := range opts {
		builder = opt.CompileUpdate(builder)
	}

	res, err := builder.ExecContext(ctx)
	if err != nil {
		txn.AppendError(err)
		return -1, err
	}

	affectedRow, err := res.RowsAffected()
	txn.AppendError(err)
	return affectedRow, err
}

func (r *EmployeeRepoImpl) SoftDelete(ctx context.Context, id int) (int64, error) {
	txn, err := dbtxn.Use(ctx, r.DB)
	if err != nil {
		return -1, err
	}

	builder := sq.
		Update("employees").
		Set("deleted_at", "now()").
		Where(sq.Eq{"id": id}).
		PlaceholderFormat(sq.Dollar).
		RunWith(txn)

	res, err := builder.ExecContext(ctx)
	if err != nil {
		txn.AppendError(err)
		return -1, err
	}
	affectedRow, err := res.RowsAffected()
	txn.AppendError(err)

	return affectedRow, nil
}
