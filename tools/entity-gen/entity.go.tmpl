// Code generated by `tools/entity-gen`. DO NOT EDIT.
package {{.PackageName}}

import (
	"context"
	"database/sql"

	"github.com/imantung/boilerplate-go-backend/internal/app/infra/di"
	"github.com/imantung/boilerplate-go-backend/pkg/repokit"
	"github.com/imantung/dbtxn"

	sq "github.com/Masterminds/squirrel"
)


var(
	{{.StructName}}TableName = "{{.TableName}}"
	{{.StructName}}Columns = struct { {{ range $col := .Columns }}
		{{$col.FieldName}} string{{ end }}
	}{ {{ range $col := .Columns }}
		{{$col.FieldName}}: "{{$col.ColumnName}}",{{ end }}
	}
) 


type (
	{{.StructName}} struct { {{ range $col := .Columns }}
		{{$col.FieldName}} {{$col.FieldType}} `column:"{{$col.ColumnName}}"`{{ end }}
	}
	{{.StructName}}Repo interface {
		Count(context.Context, ...repokit.SelectOption) (int64, error)
		Select(context.Context, ...repokit.SelectOption) ([]*{{.StructName}}, error)
		Insert(context.Context, *{{.StructName}}) ({{.PrimaryKey.FieldType}}, error)
		SoftDelete(context.Context, {{.PrimaryKey.FieldType}}) (int64, error)
		Update(context.Context, *{{.StructName}}, ...repokit.UpdateOption) (int64, error)
		Patch(context.Context, *{{.StructName}}, ...repokit.UpdateOption) (int64, error)
	}
	{{.StructName}}RepoImpl struct {
		*sql.DB
	}
)

var _ = di.Provide(New{{.StructName}}Repo)

func New{{.StructName}}Repo(db *sql.DB) {{.StructName}}Repo {
	return &{{.StructName}}RepoImpl{
		DB: db,
	}
}

func (r *{{.StructName}}RepoImpl) Count(ctx context.Context, opts ...repokit.SelectOption) (int64, error) {
	txn, err := dbtxn.Use(ctx, r.DB)
	if err != nil {
		return -1, err
	}
	builder := sq.
		Select("count(1)").
		From("{{.TableName}}").
		Where(sq.Eq{"deleted_at": nil}).
		RunWith(txn)

	for _, opt := range opts {
		builder = opt.CompileSelect(builder)
	}

	row := builder.QueryRowContext(ctx)

	var cnt int64
	if err := row.Scan(&cnt); err != nil {
		return -1, err
	}
	return cnt, nil
}

func (r *{{.StructName}}RepoImpl) Select(ctx context.Context, opts ...repokit.SelectOption) ([]*{{.StructName}}, error) {
	txn, err := dbtxn.Use(ctx, r.DB)
	if err != nil {
		return nil, err
	}
	builder := sq.
		Select({{ range $col := .Columns }}
			"{{ $col.ColumnName }}",{{ end }}
		).
		From("{{.TableName}}").
		Where(sq.Eq{"deleted_at": nil}).
		PlaceholderFormat(sq.Dollar).
		RunWith(txn)

	for _, opt := range opts {
		builder = opt.CompileSelect(builder)
	}

	rows, err := builder.QueryContext(ctx)
	if err != nil {
		return nil, err
	}

	list := make([]*{{.StructName}}, 0)
	for rows.Next() {
		ent := new({{.StructName}})
		err := rows.Scan({{ range $col := .Columns }}
			&ent.{{ $col.FieldName }},{{ end }}
		)
		if err != nil {
			return nil, err 
		}
		list = append(list, ent)
	}
	return list, nil
}

func (r *{{.StructName}}RepoImpl) Insert(ctx context.Context, ent *{{.StructName}}) ({{.PrimaryKey.FieldType}}, error) {
	txn, err := dbtxn.Use(ctx, r.DB)
	if err != nil {
		return {{.PrimaryKey.DefaultValue}}, err
	}

	builder := sq.
		Insert("{{.TableName}}").
		Columns({{ range $col := .Columns }}{{if and (not $col.IsPrimaryKey) (not $col.IsAuditColumn) }}
			"{{$col.ColumnName}}",{{end}}{{end}}
		).
		Suffix(
			"RETURNING {{.PrimaryKey.ColumnName}}",
		).
		PlaceholderFormat(sq.Dollar).
		Values({{range $col := .Columns }}{{if and (not $col.IsPrimaryKey) (not $col.IsAuditColumn)}}
			ent.{{$col.FieldName}},{{end}}{{end}}
		)

	scanner := builder.RunWith(txn).QueryRowContext(ctx)

	var id {{.PrimaryKey.FieldType}}
	if err := scanner.Scan(&id); err != nil {
		txn.AppendError(err)
		return {{.PrimaryKey.DefaultValue}}, err
	}
	return id, nil
}

func (r *{{.StructName}}RepoImpl) Update(ctx context.Context, ent *{{.StructName}}, opts ...repokit.UpdateOption) (int64, error) {
	txn, err := dbtxn.Use(ctx, r.DB)
	if err != nil {
		return -1, err
	}

	builder := sq.
		Update("{{.TableName}}").{{ range $col := .Columns }}{{if and (not $col.IsPrimaryKey) (not $col.IsAuditColumn) }}
		Set("{{$col.ColumnName}}", ent.{{$col.FieldName}}).{{end}}{{end}}
		Set("updated_at", "now()").
		PlaceholderFormat(sq.Dollar).
		RunWith(txn)

	for _, opt := range opts {
		builder = opt.CompileUpdate(builder)
	}

	res, err := builder.ExecContext(ctx)
	if err != nil {
		txn.AppendError(err)
		return -1, err
	}
	affectedRow, err := res.RowsAffected()
	txn.AppendError(err)
	return affectedRow, err
}

func (r *{{.StructName}}RepoImpl) Patch(ctx context.Context, ent *{{.StructName}}, opts ...repokit.UpdateOption) (int64, error) {
	txn, err := dbtxn.Use(ctx, r.DB)
	if err != nil {
		return -1, err
	}

	builder := sq.
		Update("{{.TableName}}").
		PlaceholderFormat(sq.Dollar).
		RunWith(txn)
	{{ range $col := .Columns }}{{if and (not $col.IsPrimaryKey) (not $col.IsAuditColumn) }}
	if !repokit.IsZero(ent.{{$col.FieldName}}) {
		builder = builder.Set("{{$col.ColumnName}}", ent.{{$col.FieldName}})
	}{{end}}{{end}}
	
	builder = builder.Set("updated_at", "now()")

	for _, opt := range opts {
		builder = opt.CompileUpdate(builder)
	}

	res, err := builder.ExecContext(ctx)
	if err != nil {
		txn.AppendError(err)
		return -1, err
	}

	affectedRow, err := res.RowsAffected()
	txn.AppendError(err)
	return affectedRow, err
}

func (r *{{.StructName}}RepoImpl) SoftDelete(ctx context.Context, id {{.PrimaryKey.FieldType}}) (int64, error) {
	txn, err := dbtxn.Use(ctx, r.DB)
	if err != nil {
		return -1, err
	}

	builder := sq.
		Update("{{.TableName}}").
		Set("deleted_at", "now()").
		Where(sq.Eq{"id": id}).
		PlaceholderFormat(sq.Dollar).
		RunWith(txn)

	res, err := builder.ExecContext(ctx)
	if err != nil {
		txn.AppendError(err)
		return -1, err
	}
	affectedRow, err := res.RowsAffected()
	txn.AppendError(err)

	return affectedRow, nil
}
